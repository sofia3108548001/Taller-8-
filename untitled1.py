# -*- coding: utf-8 -*-
"""Untitled1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1AA3tvalkojOYgtSDBwAiwokDWkrzl1vo
"""

# Quick start guide / Guia de inicio rapido

"""Este tutorial cubre algunos patrones de uso básicos y mejores prácticas para ayudarlo a comenzar con Matplotlib."""

import matplotlib.pyplot as plt
import numpy as np

import matplotlib as mpl

"""Lo primero que realizamos es la importación de la biblioteca matplotlib llamando a la función pyplot la cual crea graficos matematicos y ponemos un alisas

EJEMPLO: Matplotlib grafica sus datos en .Figures , cada uno de los cuales puede contener uno o más Axes, un área donde los puntos se pueden especificar en términos de coordenadas xy .La forma más sencilla de crear una figura con ejes es utilizando pyplot.subplots. Luego podemos usar Axes.plotpara dibujar algunos datos en los Ejes:
"""

fig, ax = plt.subplots()  # Create a figure containing a single axes.
ax.plot([1, 2, 3, 4], [1, 4, 2, 3])  # Plot some data on the axes.

"""plt.subplots() es un método de conveniencia que crea una nueva figura y un conjunto de ejes. Si no se especifican argumentos, por defecto crea una sola figura con un solo conjunto de ejes.
Cuando asignamos fig, ax = plt.subplots(), estamos desempaquetando el resultado devuelto por plt.subplots() en dos variables: fig y ax.
Puede ser necesario llamar a plt.show() para que muestre la figura

# Figure

La figura realiza un seguimiento de todos los elementos secundarios Axes, un grupo de artistas "especiales" (títulos, leyendas de figuras, barras de colores, etc.) e incluso subfiguras anidadas.

La forma más sencilla de crear una nueva figura es con pyplot:
"""

fig = plt.figure()  # an empty figure with no Axes
fig, ax = plt.subplots()  # a figure with a single Axes
fig, axs = plt.subplots(2, 2)  # a figure with a 2x2 grid of Axes
# a figure with one axes on the left, and two on the right:
fig, axs = plt.subplot_mosaic([['left', 'right_top'],
                               ['left', 'right_bottom']])

"""1. `fig = plt.figure()`: Crea una nueva figura vacía sin ejes. Esta línea crea una instancia de figura que puedes utilizar para añadir conjuntos de ejes o personalizar la figura antes de agregar ejes.

2. `fig, ax = plt.subplots()`: Crea una nueva figura con un único conjunto de ejes. Esta línea es una forma conveniente de crear una figura con un conjunto de ejes para hacer un solo gráfico. `ax` es el conjunto de ejes que puedes utilizar para trazar tus datos.

3. `fig, axs = plt.subplots(2, 2)`: Crea una nueva figura con una cuadrícula de 2x2 de conjuntos de ejes. En este caso, `axs` es una matriz de conjuntos de ejes, donde puedes acceder a cada conjunto de ejes individualmente para trazar tus datos.

4. `fig, axs = plt.subplot_mosaic([['left', 'right_top'], ['left', 'right_bottom']])`: Crea una figura con un diseño personalizado de conjuntos de ejes utilizando la función `subplot_mosaic()`. En este ejemplo, especificamos un diseño de mosaico donde hay un conjunto de ejes en la posición 'left' y dos conjuntos de ejes en la posición 'right_top' y 'right_bottom', respectivamente.

#Axes

Los objetos Axes son artistas adjuntos a una Figura que contienen una región para trazar datos. Generalmente, incluyen dos (o tres en el caso de gráficos 3D) objetos Axis que proporcionan marcas y etiquetas de marcas para proporcionar escalas para los datos en el Axes. Cada Axes también tiene un título (establecido mediante set_title()), una etiqueta x (establecida mediante set_xlabel()) y una etiqueta y (establecida mediante set_ylabel()).

La clase Axes y sus funciones miembro son el punto de entrada principal para trabajar con la interfaz OOP, y tienen la mayoría de los métodos de trazado definidos en ellos. Por ejemplo, ax.plot() utiliza el método plot.

># Axis

Estos objetos establecen la escala y los límites y generan ticks, La combinación de correcto Locatory Formatterbrinda un control muy preciso sobre las ubicaciones y etiquetas de las marcas.

# Artist

Básicamente, todo lo visible en la Figura es un Artista. Esto incluye Textobjetos, Line2Dobjetos, collectionsobjetos, Patchobjetos, etc.

#Types of inputs to plotting functions

Las funciones de trazado esperan numpy.array,  numpy.ma.masked_array entrada, a los objetos a los que se puede pasar numpy.asarray. Clases que son similares a matrices ("tipo matriz"), como pandas objetos de datos, y numpy.matrixes posible que no funcionen según lo previsto. La convención común es convertirlos en numpy.arrayobjetos antes de trazar. Por ejemplo, para convertir unnumpy.matrix
"""

b = np.matrix([[1, 2], [3, 4]])
b_asarray = np.asarray(b)

np.random.seed(19680801)  # seed the random number generator.
data = {'a': np.arange(50),
        'c': np.random.randint(0, 50, 50),
        'd': np.random.randn(50)}
data['b'] = data['a'] + 10 * np.random.randn(50)
data['d'] = np.abs(data['d']) * 100

fig, ax = plt.subplots(figsize=(5, 2.7), layout='constrained')
ax.scatter('a', 'b', c='c', s='d', data=data)
ax.set_xlabel('entry a')
ax.set_ylabel('entry b')

"""La mayoría de los métodos también analizarán un objeto indexable por cadena como un dict , una matriz numpy estructurada o un archivo pandas.DataFrame. Matplotlib le permite proporcionar el dataargumento de la palabra clave y generar gráficos que pasen las cadenas correspondientes a las variables xey .

#Coding styles

Como se señaló anteriormente, existen esencialmente dos formas de utilizar Matplotlib:

Cree explícitamente figuras y ejes, y llame a métodos en ellos (el "estilo orientado a objetos (OO)").

Confíe en pyplot para crear y administrar implícitamente las figuras y los ejes, y utilice las funciones de pyplot para trazar.

Consulte Interfaces de aplicaciones (API) de Matplotlib para obtener una explicación de las compensaciones entre las interfaces implícitas y explícitas.

Entonces uno puede usar el estilo OO.
"""

x = np.linspace(0, 2, 100)  # Sample data.

# Note that even in the OO-style, we use `.pyplot.figure` to create the Figure.
fig, ax = plt.subplots(figsize=(5, 2.7), layout='constrained')
ax.plot(x, x, label='linear')  # Plot some data on the axes.
ax.plot(x, x**2, label='quadratic')  # Plot more data on the axes...
ax.plot(x, x**3, label='cubic')  # ... and some more.
ax.set_xlabel('x label')  # Add an x-label to the axes.
ax.set_ylabel('y label')  # Add a y-label to the axes.
ax.set_title("Simple Plot")  # Add a title to the axes.
ax.legend()  # Add a legend.

"""or the pyplot-style:


"""

x = np.linspace(0, 2, 100)  # Sample data.

plt.figure(figsize=(5, 2.7), layout='constrained')
plt.plot(x, x, label='linear')  # Plot some data on the (implicit) axes.
plt.plot(x, x**2, label='quadratic')  # etc.
plt.plot(x, x**3, label='cubic')
plt.xlabel('x label')
plt.ylabel('y label')
plt.title("Simple Plot")
plt.legend()

"""Además, existe un tercer enfoque, para el caso de incrustar Matplotlib en una aplicación GUI, que descarta por completo pyplot, incluso para la creación de figuras.

#Making a helper functions

Si necesita realizar los mismos gráficos una y otra vez con diferentes conjuntos de datos, o desea empaquetar fácilmente los métodos de Matplotlib, utilice la función de firma recomendada a continuación.
"""

def my_plotter(ax, data1, data2, param_dict):
    """
    A helper function to make a graph.
    """
    out = ax.plot(data1, data2, **param_dict)
    return out

data1, data2, data3, data4 = np.random.randn(4, 100)  # make 4 random data sets
fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(5, 2.7))
my_plotter(ax1, data1, data2, {'marker': 'x'})
my_plotter(ax2, data3, data4, {'marker': 'o'})

"""1. `data1, data2, data3, data4 = np.random.randn(4, 100)`: Crea cuatro conjuntos de datos aleatorios, cada uno con 100 puntos, utilizando la función `np.random.randn()`. Esta función genera números aleatorios tomados de una distribución normal estándar (Gaussiana) con media 0 y desviación estándar 1.

2. `fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(5, 2.7))`: Crea una figura con dos subplots en una fila utilizando la función `plt.subplots()`. El parámetro `1` especifica que queremos una sola fila de subplots, el parámetro `2` especifica que queremos dos subplots en esa fila, y `figsize=(5, 2.7)` establece el tamaño de la figura en 5 pulgadas de ancho y 2.7 pulgadas de alto. Se asignan los ejes a las variables `ax1` y `ax2`.

3. `my_plotter(ax1, data1, data2, {'marker': 'x'})`: Llama a la función `my_plotter()` para trazar los datos en el primer subplot (`ax1`). La función `my_plotter()` toma tres argumentos: los ejes en los que se realizará el gráfico (`ax1`), los datos `data1` y `data2` que se trazarán en el gráfico, y un diccionario de argumentos opcionales que se utilizarán para personalizar el gráfico. En este caso, se pasa el argumento `{'marker': 'x'}` que especifica que los puntos en el gráfico se marcarán con 'x'.

4. `my_plotter(ax2, data3, data4, {'marker': 'o'})`: Similar al paso anterior, pero para el segundo subplot (`ax2`). Se trazan los datos `data3` y `data4` y se utiliza el argumento `{'marker': 'o'}` para especificar que los puntos se marcarán con 'o'.

#Styling Artists

La mayoría de los métodos de trazado tienen opciones de estilo para los Artistas, a las que se puede acceder cuando se llama a un método de trazado o desde un "configurador" en la Artista. En el siguiente gráfico configuramos manualmente el color , el ancho de línea y el estilo de línea de los artistas creados por plot, y configuramos el estilo de línea de la segunda línea después del hecho con set_linestyle.
"""

fig, ax = plt.subplots(figsize=(5, 2.7))
x = np.arange(len(data1))
ax.plot(x, np.cumsum(data1), color='blue', linewidth=3, linestyle='--')
l, = ax.plot(x, np.cumsum(data2), color='orange', linewidth=2)
l.set_linestyle(':')

"""#Colors

Algunos artistas tomarán varios colores. es decir, para una scattertrama, el borde de los marcadores puede ser de diferentes colores respecto al interior:
"""

fig, ax = plt.subplots(figsize=(5, 2.7))
ax.scatter(data1, data2, s=50, facecolor='C0', edgecolor='k')

"""#Linewidths, linestyles, and markersizes

El tamaño del marcador depende del método que se utilice. plotespecifica el tamaño del marcador en puntos y generalmente es el "diámetro" o ancho del marcador. scatterespecifica el tamaño del marcador como aproximadamente proporcional al área visual del marcador. Hay una variedad de estilos de marcador disponibles como códigos de cadena (consulte markers), o los usuarios pueden definir los suyos propios MarkerStyle(consulte Referencia de marcador ):
"""

fig, ax = plt.subplots(figsize=(5, 2.7))
ax.plot(data1, 'o', label='data1')
ax.plot(data2, 'd', label='data2')
ax.plot(data3, 'v', label='data3')
ax.plot(data4, 's', label='data4')
ax.legend()

"""#Axes labels and text

set_xlabel, set_ylabely set_titlese utilizan para agregar texto en las ubicaciones indicadas (consulte Texto en Matplotlib para obtener más información). El texto también se puede agregar directamente a los gráficos usando text:
"""

mu, sigma = 115, 15
x = mu + sigma * np.random.randn(10000)
fig, ax = plt.subplots(figsize=(5, 2.7), layout='constrained')
# the histogram of the data
n, bins, patches = ax.hist(x, 50, density=True, facecolor='C0', alpha=0.75)

ax.set_xlabel('Length [cm]')
ax.set_ylabel('Probability')
ax.set_title('Aardvark lengths\n (not really)')
ax.text(75, .025, r'$\mu=115,\ \sigma=15$')
ax.axis([55, 175, 0, 0.03])
ax.grid(True)

"""Todas las textfunciones devuelven una matplotlib.text.Textinstancia. Al igual que con las líneas anteriores, puede personalizar las propiedades pasando argumentos de palabras clave a las funciones de texto:"""

t = ax.set_xlabel('my data', fontsize=14, color='red')

"""#Annotations

También podemos anotar puntos en un gráfico, a menudo conectando una flecha que apunta a xy a un fragmento de texto en xytext :
"""

fig, ax = plt.subplots(figsize=(5, 2.7))

t = np.arange(0.0, 5.0, 0.01)
s = np.cos(2 * np.pi * t)
line, = ax.plot(t, s, lw=2)

ax.annotate('local max', xy=(2, 1), xytext=(3, 1.5),
            arrowprops=dict(facecolor='black', shrink=0.05))

ax.set_ylim(-2, 2)

"""#Legends

A menudo queremos identificar líneas o marcadores con un Axes.legend:
Las leyendas en Matplotlib son bastante flexibles en cuanto a diseño, ubicación y qué artistas pueden representar. Se analizan en detalle en la guía Leyenda.
"""

fig, ax = plt.subplots(figsize=(5, 2.7))
ax.plot(np.arange(len(data1)), data1, label='data1')
ax.plot(np.arange(len(data2)), data2, label='data2')
ax.plot(np.arange(len(data3)), data3, 'd', label='data3')
ax.legend()

"""#Scales

Además de la escala lineal, Matplotlib proporciona escalas no lineales, como una escala logarítmica. Dado que las escalas logarítmicas se utilizan mucho, también existen métodos directos como loglog, semilogxy semilogy. La escala establece el mapeo de los valores de datos al espaciado a lo largo del Eje. Esto sucede en ambas direcciones y se combina en una transformación , que es la forma en que Matplotlib asigna las coordenadas de los datos a los ejes, la figura o las coordenadas de la pantalla. Ver Tutorial de Transformaciones .
"""

fig, axs = plt.subplots(1, 2, figsize=(5, 2.7), layout='constrained')
xdata = np.arange(len(data1))  # make an ordinal for this
data = 10**data1
axs[0].plot(xdata, data)

axs[1].set_yscale('log')
axs[1].plot(xdata, data)

"""#Tick locators and formatters

Cada eje tiene un localizador de marcas y un formateador que eligen en qué lugar de los objetos del eje colocar las marcas. Una interfaz simple para esto es set_xticks:Diferentes escalas pueden tener diferentes localizadores y formateadores; por ejemplo, la escala logarítmica anterior utiliza LogLocatory LogFormatter
"""

fig, axs = plt.subplots(2, 1, layout='constrained')
axs[0].plot(xdata, data1)
axs[0].set_title('Automatic ticks')

axs[1].plot(xdata, data1)
axs[1].set_xticks(np.arange(0, 100, 30), ['zero', '30', 'sixty', '90'])
axs[1].set_yticks([-1.5, 0, 1.5])  # note that we don't need to specify labels
axs[1].set_title('Manual ticks')

"""#Plotting dates and strings

Matplotlib puede manejar el trazado de matrices de fechas y matrices de cadenas, así como números de punto flotante. Estos obtienen localizadores y formateadores especiales según corresponda. Para fechas:
"""

fig, ax = plt.subplots(figsize=(5, 2.7), layout='constrained')
dates = np.arange(np.datetime64('2021-11-15'), np.datetime64('2021-12-25'),
                  np.timedelta64(1, 'h'))
data = np.cumsum(np.random.randn(len(dates)))
ax.plot(dates, data)
cdf = mpl.dates.ConciseDateFormatter(ax.xaxis.get_major_locator())
ax.xaxis.set_major_formatter(cdf)

"""Para las cadenas, obtenemos un trazado categórico
Si pasa 1000 cadenas, Matplotlib pensará que se refiere a 1000 categorías y agregará 1000 ticks a su trama.
"""

fig, ax = plt.subplots(figsize=(5, 2.7), layout='constrained')
categories = ['turnips', 'rutabaga', 'cucumber', 'pumpkins']

ax.bar(categories, np.random.rand(len(categories)))

"""#Additional Axis objects

Trazar datos de diferente magnitud en un gráfico puede requerir un eje y adicional. Dicho eje se puede crear agregando twinxnuevos ejes con un eje x invisible y un eje y colocado a la derecha (de manera análoga a twiny).
De manera similar, puedes agregar un eje secondary_xaxiso secondary_yaxisque tenga una escala diferente al eje principal para representar los datos en diferentes escalas o unidades
"""

fig, (ax1, ax3) = plt.subplots(1, 2, figsize=(7, 2.7), layout='constrained')
l1, = ax1.plot(t, s)
ax2 = ax1.twinx()
l2, = ax2.plot(t, range(len(t)), 'C1')
ax2.legend([l1, l2], ['Sine (left)', 'Straight (right)'])

ax3.plot(t, s)
ax3.set_xlabel('Angle [rad]')
ax4 = ax3.secondary_xaxis('top', functions=(np.rad2deg, np.deg2rad))
ax4.set_xlabel('Angle [°]')

"""#Color mapped data

A menudo queremos tener una tercera dimensión en una trama representada por colores en un mapa de colores. Matplotlib tiene varios tipos de gráficos que hacen esto:
"""

X, Y = np.meshgrid(np.linspace(-3, 3, 128), np.linspace(-3, 3, 128))
Z = (1 - X/2 + X**5 + Y**3) * np.exp(-X**2 - Y**2)

fig, axs = plt.subplots(2, 2, layout='constrained')
pc = axs[0, 0].pcolormesh(X, Y, Z, vmin=-1, vmax=1, cmap='RdBu_r')
fig.colorbar(pc, ax=axs[0, 0])
axs[0, 0].set_title('pcolormesh()')

co = axs[0, 1].contourf(X, Y, Z, levels=np.linspace(-1.25, 1.25, 11))
fig.colorbar(co, ax=axs[0, 1])
axs[0, 1].set_title('contourf()')

pc = axs[1, 0].imshow(Z**2 * 100, cmap='plasma',
                          norm=mpl.colors.LogNorm(vmin=0.01, vmax=100))
fig.colorbar(pc, ax=axs[1, 0], extend='both')
axs[1, 0].set_title('imshow() with LogNorm()')

pc = axs[1, 1].scatter(data1, data2, c=data3, cmap='RdBu_r')
fig.colorbar(pc, ax=axs[1, 1], extend='both')
axs[1, 1].set_title('scatter()')

"""

1. `X, Y = np.meshgrid(np.linspace(-3, 3, 128), np.linspace(-3, 3, 128))`: Crea una cuadrícula de puntos en el rango [-3, 3] tanto para el eje x como para el eje y, con 128 puntos en cada dirección. Esto se hace utilizando la función `np.meshgrid()` en combinación con `np.linspace()`.

2. `Z = (1 - X/2 + X**5 + Y**3) * np.exp(-X**2 - Y**2)`: Calcula los valores de Z para cada punto en la cuadrícula (X, Y) utilizando una función matemática. Estos valores se utilizarán para crear diferentes tipos de gráficos.

3. `fig, axs = plt.subplots(2, 2, layout='constrained')`: Crea una figura con un diseño de 2x2 para alojar los cuatro subgráficos. `axs` es una matriz de ejes que representan cada uno de los subgráficos.

4. Para cada uno de los subgráficos:
   - Se utiliza una función específica de `matplotlib` para crear el tipo de visualización deseado (`pcolormesh()`, `contourf()`, `imshow()`, `scatter()`).
   - Se agrega una barra de color asociada a la visualización utilizando `fig.colorbar()`.
   - Se establece un título para el subgráfico utilizando `ax.set_title()`.

Este código muestra cómo crear y personalizar diferentes tipos de visualizaciones en una única figura utilizando `matplotlib`. Los tipos de visualizaciones incluyen gráficos de malla de colores (`pcolormesh()`), mapas de contorno (`contourf()`), imágenes (`imshow()`) y gráficos de dispersión (`scatter()`)."""